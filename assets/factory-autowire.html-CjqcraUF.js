import{_ as r,r as a,o as c,c as i,a as e,b as t,d as n,e as s}from"./app-DD6itCjZ.js";const d={},l=e("h1",{id:"自动装配协作者-autowiring-collaborators",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#自动装配协作者-autowiring-collaborators"},[e("span",null,"自动装配协作者（Autowiring Collaborators）")])],-1),p=e("p",null,[t("Spring容器可以自动装配协作Bean之间的关系。 你可以通过检查"),e("code",null,"ApplicationContext"),t("的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。")],-1),g=e("p",null,[e("strong",null,"自动装配的优势")],-1),u=e("strong",null,"减少手动配置",-1),h={href:"https://docs.spring.io/spring-framework/reference/core/beans/child-bean-definitions.html",target:"_blank",rel:"noopener noreferrer"},m=e("li",null,[e("strong",null,"动态更新配置"),t("：随着项目的发展，对象可能会增加新的依赖。自动装配能够适应这种变化，自动满足新的依赖关系，而无需手动更新配置。 这一点在项目的迭代开发过程中尤为有用。同时，当项目稳定下来后，开发者仍然可以选择切换到显式装配，以获得更精确的控制。")],-1),_=e("p",null,[e("strong",null,"四种自动装配模式")],-1),b={href:"https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"<bean/>",-1),f=e("code",null,"autowire",-1),B=s("<table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td><strong>默认模式</strong>：<br>不执行自动装配。开发者需要使用<code>ref</code>标签显式声明依赖关系。</td></tr><tr><td>byName</td><td><strong>按名称自动装配</strong>：<br>容器会寻找一个属性名称或setter方法名称相匹配的Bean定义将其注入。<br>例如：Bean的属性名为<code>master</code>（也就是说，它有一个<code>setMaster(..)</code>方法），Spring会寻找名为<code>master</code>的Bean定义来注入。</td></tr><tr><td>byType</td><td><strong>按类型自动装配</strong>：<br>容器会寻找与属性类型相匹配的Bean定义将其注入。如果存在多个相同类型的Bean，将抛出异常。</td></tr><tr><td>constructor</td><td><strong>按构造函数参数类型自动装配</strong>：<br>容器会寻找与构造函数参数类型相匹配的Bean定义将其注入。如果没有匹配的Bean定义，将抛出异常。这种模式确保了Bean在创建时其必需的依赖就已经被满足。</td></tr></tbody></table><p>利用<code>byType</code>或<code>constructor</code>自动装配模式，你可以装配数组（<code>array</code>）和泛型集合（<code>collection</code>）。 在这种模式下，Spring容器会自动寻找所有与所需类型相匹配的Bean，并将其注入到定义的数组或集合中，从而满足配置的依赖关系。 此外，当预期的键（key）类型为<code>String</code>时，还可以自动装配一个强类型化的<code>Map</code>实例。 在这个<code>Map</code>中，键（key）将是Bean的名称，而值（value）则是所有匹配期望类型的Bean实例。</p><blockquote><p>这样的自动装配<code>Map</code>实例，为我们提供了一种便捷的方式来管理和访问一组具有相同类型的Bean，特别是当我们需要根据名称快速查找特定的Bean时。</p></blockquote>",3);function w(k,S){const o=a("ExternalLinkIcon");return c(),i("div",null,[l,p,g,e("ul",null,[e("li",null,[u,t("：自动装配可以显著减少对手动指定属性或构造方法参数的需求。 "),e("a",h,[t("其他机制"),n(o)]),t(" ，如bean模板，在这方面也是非常有价值的。")]),m]),_,e("p",null,[t("在使用XML配置时， （参阅 "),e("a",b,[t("依赖注入"),n(o)]),t("）， 可以通过"),y,t("元素的"),f,t("属性来定义Bean的自动装配模式。 Spring提供了四种自动装配模式，允许你为每个Bean单独指定使用哪种模式。以下是这四种模式的详细描述：")]),B])}const T=r(d,[["render",w],["__file","factory-autowire.html.vue"]]),C=JSON.parse('{"path":"/spring-framework/core/dependencies/factory-autowire.html","title":"自动装配协作者","lang":"zh-CN","frontmatter":{"title":"自动装配协作者","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-03-26T00:00:00.000Z","category":"Spring","tag":"Spring Framework","description":"自动装配协作者（Autowiring Collaborators） Spring容器可以自动装配协作Bean之间的关系。 你可以通过检查ApplicationContext的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。 自动装配的优势 减少手动配置：自动装配可以显著减少对手动指定属性或构造方法参数的需求。 其他机制 ，如bean...","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/spring-framework/core/dependencies/factory-autowire.html"}],["meta",{"property":"og:site_name","content":"极客空间"}],["meta",{"property":"og:title","content":"自动装配协作者"}],["meta",{"property":"og:description","content":"自动装配协作者（Autowiring Collaborators） Spring容器可以自动装配协作Bean之间的关系。 你可以通过检查ApplicationContext的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。 自动装配的优势 减少手动配置：自动装配可以显著减少对手动指定属性或构造方法参数的需求。 其他机制 ，如bean..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-02T09:44:02.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"Spring Framework"}],["meta",{"property":"article:published_time","content":"2024-03-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-02T09:44:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"自动装配协作者\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-02T09:44:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[],"git":{"createdTime":1711526465000,"updatedTime":1712051042000,"contributors":[{"name":"zhouyu","email":"zhouyu@liquido.cn","commits":3}]},"readingTime":{"minutes":2.6,"words":780},"filePathRelative":"spring-framework/core/dependencies/factory-autowire.md","localizedDate":"2024年3月26日","excerpt":"\\n<p>Spring容器可以自动装配协作Bean之间的关系。\\n你可以通过检查<code>ApplicationContext</code>的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。</p>\\n<p><strong>自动装配的优势</strong></p>\\n<ul>\\n<li><strong>减少手动配置</strong>：自动装配可以显著减少对手动指定属性或构造方法参数的需求。\\n<a href=\\"https://docs.spring.io/spring-framework/reference/core/beans/child-bean-definitions.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">其他机制</a>\\n，如bean模板，在这方面也是非常有价值的。</li>\\n<li><strong>动态更新配置</strong>：随着项目的发展，对象可能会增加新的依赖。自动装配能够适应这种变化，自动满足新的依赖关系，而无需手动更新配置。\\n这一点在项目的迭代开发过程中尤为有用。同时，当项目稳定下来后，开发者仍然可以选择切换到显式装配，以获得更精确的控制。</li>\\n</ul>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{T as comp,C as data};
