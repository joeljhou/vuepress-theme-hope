import{_ as o,r as p,o as c,c as l,a as n,b as e,d as s,e as t}from"./app-CBMYhfyn.js";const i={},r=n("h1",{id:"bean作用域-scope",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#bean作用域-scope"},[n("span",null,"Bean作用域（Scope）")])],-1),u=n("p",null,"当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。",-1),d=n("code",null,"ApplicationContext",-1),k={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom",target:"_blank",rel:"noopener noreferrer"},g=t("<table><thead><tr><th>Bean作用域（Scope）</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>(默认) 在整个应用程序中只创建一个Bean实例</td></tr><tr><td>prototype</td><td>每次请求时，创建一个新的Bean实例</td></tr><tr><td>request</td><td>Web程序中，为每个HTTP请求创建一个Bean实例</td></tr><tr><td>session</td><td>Web程序中，为每个HTTP会话创建一个Bean实例</td></tr><tr><td>application</td><td>Web程序中，为每个<code>ServletContext</code>创建一个Bean实例</td></tr><tr><td>websocket</td><td>Web程序中，为每个<code>WebSocket</code>连接创建一个Bean实例</td></tr></tbody></table>",1),m={href:"https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/support/SimpleThreadScope.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom-using",target:"_blank",rel:"noopener noreferrer"},b=t(`<h2 id="单例作用域-singleton" tabindex="-1"><a class="header-anchor" href="#单例作用域-singleton"><span>单例作用域（singleton）</span></a></h2><p>单例作用域（singleton scope）是Spring框架中Bean定义的默认作用域。 当你将一个Bean定义为单例作用域时，对所有具有匹配ID或名称的Bean的调用都会返回这个特定的Bean实例。</p><p>下图说明了单例作用域：</p><figure><img src="http://img.geekyspace.cn/pictures/2024/singleton.png" alt="singleton" tabindex="0" loading="lazy"><figcaption>singleton</figcaption></figure><p>Spring的单例Bean概念与《设计模式》GoF（四人帮）书中定义的单例模式有所不同。</p><ul><li>GoF单例模式通过硬编码对象的作用域，确保每个类加载器（ClassLoader）下，仅有一个特定类的实例被创建</li><li>Spring单例的作用域最好被描述为每个容器（per-container）和每个bean（per-bean）</li></ul><p>单例作用域是Spring中的默认作用域。要在XML中将一个Bean定义为单例，参考按照以下示例：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- 以下是等效的冗余写法（因为单例作用域是默认的） --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>singleton<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原型作用域-prototype" tabindex="-1"><a class="header-anchor" href="#原型作用域-prototype"><span>原型作用域（prototype）</span></a></h2><p>原型作用域（prototype scope）的Bean部署，意味着每次请求该特定Bean时都会创建一个新的Bean实例。 也就是说，当一个Bean被注入到另一个Bean中，或者通过容器上的<code>getBean()</code>方法调用请求它，每次都会产生一个新的实例。 作为一项规则，将原型（prototype）作用域用于所有有状态的Bean，将单例（singleton）作用域用于无状态的Bean。</p><p>下图说明了原型作用域：</p><figure><img src="http://img.geekyspace.cn/pictures/2024/prototype.png" alt="prototype" tabindex="0" loading="lazy"><figcaption>prototype</figcaption></figure><p>（注意⚠️：以上图片中的数据访问对象（DAO）通常不配置为原型作用域，因为典型的DAO不持有任何会话状态。）</p><p>以下示例展示了如何在XML中将一个Bean定义为原型作用域：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prototype<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,15),h=n("code",null,"@PostConstruct",-1),f=n("code",null,"@PreDestroy",-1),S={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html#beans-factory-extension-bpp",target:"_blank",rel:"noopener noreferrer"},B=n("code",null,"new",-1),x={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle",target:"_blank",rel:"noopener noreferrer"},q=n("h2",{id:"单例bean与原型bean依赖",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#单例bean与原型bean依赖"},[n("span",null,"单例Bean与原型Bean依赖")])],-1),y=n("p",null,"当你在单例作用域的Bean中使用对原型作用域Bean的依赖时，请注意依赖关系是在实例化时解析的。 因此，如果你将一个原型作用域的Bean注入到一个单例作用域的Bean中，将会实例化一个新的原型Bean，然后将其依赖注入到单例Bean中。 这个原型实例是唯一供给单例作用域Bean的实例。",-1),_={href:"https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html",target:"_blank",rel:"noopener noreferrer"},w=t(`<h2 id="请求、会话、应用程序和websocket作用域" tabindex="-1"><a class="header-anchor" href="#请求、会话、应用程序和websocket作用域"><span>请求、会话、应用程序和WebSocket作用域</span></a></h2><p><code>request</code>、<code>session</code>、<code>application</code>和<code>webSocket</code>作用域只有在使用Web感知（aware）的Spring应用程序上下文实现， 如<code>XmlWebApplicationContext</code>时才可用。 如果你在常规的Spring IoC容器中使用这些作用域，比如<code>ClassPathXmlApplicationContext</code>， 将会抛出一个IllegalStateException异常，提示未知的Bean作用域。</p><h3 id="初始web配置" tabindex="-1"><a class="header-anchor" href="#初始web配置"><span>初始Web配置</span></a></h3><p>为了支持对<code>request</code>、<code>session</code>、<code>application</code>和<code>websocket</code>级别的Bean进行作用域范围设置（即Web作用域的Bean）， 在定义Bean之前需要进行一些简单的初始配置。（对于标准作用域：单例（<code>singleton</code>）和原型（<code>prototype</code>）则不需要进行这些初始设置。）</p><p>你如何完成这个初始设置取决于你的特定Servlet环境。</p><p>如果你在Spring Web MVC中访问作用域内的Bean，实际上是在一个由Spring <code>DispatcherServlet</code>处理的请求（request）中进行访问， 无需进行特殊设置。<code>DispatcherServlet</code>已经暴露了所有相关状态。</p><p>如果你使用Servlet Web容器，在Spring的 DispatcherServlet 之外处理请求（例如，在使用JSF时）， 你需要注册 org.springframework.web.context.request.RequestContextListener ServletRequestListener。 这可以通过使用 WebApplicationInitializer 接口以编程方式完成。或者，在你的Web应用程序的 web.xml 文件中添加以下声明。</p><p>如果你使用Servlet Web容器，在Spring的<code>DispatcherServlet</code>之外处理请求（例如，使用JSF）， 你需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。 可以通过使用<code>WebApplicationInitializer</code>接口以编程方式完成。或者，在你的Web应用程序的<code>web.xml</code>文件中添加以下声明：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">&gt;</span></span>
    ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">&gt;</span></span>
            org.springframework.web.context.request.RequestContextListener
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">&gt;</span></span>
    ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你在设置监听器（listener）时遇到问题，可以考虑使用Spring的<code>RequestContextFilter</code>。 过滤器（filter）的映射取决于周围Web应用程序的配置，因此你需要根据实际情况进行适当的调整。 以下示例展示了Web应用中过滤器的部分配置：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">&gt;</span></span>
    ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>requestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.RequestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>requestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
    ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>DispatcherServlet</code>、<code>RequestContextListener</code>和<code>RequestContextFilter</code>都执行着相同的作用，即把HTTP请求对象绑定到正在处理该请求的线程（Thread）上。 这使得<strong>请求范围</strong>（request-scoped）和<strong>会话范围</strong>（session-scoped）的Bean在整个调用链中更下游可用。</p><h3 id="request-scope" tabindex="-1"><a class="header-anchor" href="#request-scope"><span>Request Scope</span></a></h3><p>以下是一个用于定义Bean的XML配置的示例：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>loginAction<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.LoginAction<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>request<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Spring容器使用<code>loginAction</code> Bean定义为每个HTTP请求创建一个新的<code>LoginAction</code> Bean实例。 换句话说，<code>loginAction</code> Bean的作用域是HTTP请求级别的。 你可以随意更改创建的实例的内部状态，因为从同一个<code>loginAction</code> Bean定义中创建的其他实例不会看到这些状态的变化。 它们是针对单个请求的特定状态。当请求完成处理时，该请求所涉及的Bean会被丢弃。</p><p>当使用注解驱动（annotation-driven）的组件或Java配置时，你可以使用<code>@RequestScope</code>注解将组件分配到请求作用域（Request Scope）。 以下示例展示了如何实现：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@RequestScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginAction</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="session-scope" tabindex="-1"><a class="header-anchor" href="#session-scope"><span>Session Scope</span></a></h3><p>以下是一个用于定义Bean的XML配置的示例：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Spring容器使用<code>userPreferences</code> Bean定义为单个HTTP 会话（Session）的生命周期创建一个新的<code>UserPreferences</code> Bean实例。 换句话说，<code>userPreferences</code> Bean的作用域实际上是HTTP会话级别的。 与<a href="#request-scope">请求作用域</a>的Bean一样，你可以随意更改创建的实例的内部状态， 因为其他使用相同<code>userPreferences</code> Bean定义创建的实例所在的HTTP会话实例不会看到这些状态的变化，因为它们是针对单个HTTP会话的特定状态。 当HTTP会话（Session）最终被丢弃时，与该特定HTTP会话范围关联的Bean也会被丢弃。</p><p>当使用注解驱动（annotation-driven）的组件或Java配置时，你可以使用<code>@SessionScope</code>注解将组件分配到会话作用域（Session Scope）。 以下示例展示了如何实现：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@SessionScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserPreferences</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="application-scope" tabindex="-1"><a class="header-anchor" href="#application-scope"><span>Application Scope</span></a></h3><p>以下是一个用于定义Bean的XML配置的示例：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>appPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.AppPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>application<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Spring容器使用<code>appPreferences</code> Bean定义为整个Web应用程序创建一个新的<code>AppPreferences</code> Bean实例。 换句话说，<code>appPreferences</code> Bean的作用域是<code>ServletContext</code>级别，并作为常规的<code>ServletContext</code>属性存储。 这与Spring的单例Bean有些类似，但有两个重要区别：</p><ol><li>它是每个<code>ServletContext</code>的单例，而不是每个Spring <code>ApplicationContext</code>（在任何给定的Web应用程序中可能有多个ApplicationContext）</li><li>并且它实际上是作为<code>ServletContext</code>属性暴露和可见的</li></ol><p>当使用注解驱动（annotation-driven）的组件或Java配置时，你可以使用<code>@ApplicationScope</code>注解将组件分配到应用程序作用域（Application Scope）。 以下示例展示了如何实现：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@ApplicationScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppPreferences</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="websocket-scope" tabindex="-1"><a class="header-anchor" href="#websocket-scope"><span>WebSocket Scope</span></a></h3>`,32),T={href:"https://docs.spring.io/spring-framework/reference/web/websocket/stomp/scope.html",target:"_blank",rel:"noopener noreferrer"},C=t('<h3 id="bean-scope作为依赖项" tabindex="-1"><a class="header-anchor" href="#bean-scope作为依赖项"><span>Bean Scope作为依赖项</span></a></h3><h2 id="自定义作用域" tabindex="-1"><a class="header-anchor" href="#自定义作用域"><span>自定义作用域</span></a></h2><h3 id="创建自定义-scope" tabindex="-1"><a class="header-anchor" href="#创建自定义-scope"><span>创建自定义 Scope</span></a></h3><h3 id="使用自定义-scope" tabindex="-1"><a class="header-anchor" href="#使用自定义-scope"><span>使用自定义 Scope</span></a></h3>',4);function P(W,A){const a=p("ExternalLinkIcon");return c(),l("div",null,[r,u,n("p",null,[e("你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强大且灵活的，因为你可以通过配置选择创建的对象的作用域，而不必在Java类级别上固定对象的作用域。 Bean定义可以是多种作用域之一。Spring框架支持六种作用域，其中四种仅在使用Web感知（aware）的"),d,e("时才可用。 你还可以创建"),n("a",k,[e("自定义作用域"),s(a)]),e("。")]),g,n("blockquote",null,[n("p",null,[e("线程作用域（Thread Scope）在Spring框架中是可用的，但默认情况下并没有注册。参阅 "),n("a",m,[e("SimpleThreadScope"),s(a)]),e("。 关于如何注册此Scope或任何其他自定义Scope的说明，参阅 "),n("a",v,[e("自定义Scope"),s(a)]),e("。")])]),b,n("p",null,[e("与其他作用域相比，Spring并不管理原型（prototype）Bean的完整生命周期。 容器实例化、配置并组装原型对象，然后将其交给客户端，之后就不会对那个原型实例保持任何记录。 因此，尽管初始化生命周期回调方法（如"),h,e("）会在所有对象上调用，而不考虑作用域， 但在原型作用域的情况下，配置的销毁生命周期回调方法（如"),f,e("）则不会被调用。 客户端代码必须清理原型作用域的对象，并释放原型Bean所持有的昂贵资源。 要让Spring容器释放原型作用域Bean所持有的资源，可以尝试使用一个自定义的"),n("a",S,[e("Bean后置处理器"),s(a)]),e(" ，该后置处理器持有需要清理的Bean的引用。")]),n("p",null,[e("在某些方面，Spring容器对于原型（prototype）作用域Bean的角色类似于Java中的"),B,e("运算符。 但是，一旦Spring容器创建并交付原型Bean给客户端，所有生命周期管理的工作都需要由客户端自行处理。 有关Spring容器中Bean的生命周期的详细信息，参阅 "),n("a",x,[e("生命周期回调"),s(a)])]),q,y,n("p",null,[e("然而，假设你希望单例作用域的Bean在运行时重复获取原型作用域的Bean的新实例。 你不能将一个原型作用域的Bean注入到你的单例Bean中，因为这种注入只会在Spring容器实例化单例Bean并解析并注入其依赖时发生一次。 如果你需要在运行时多次获取原型Bean的新实例，参阅 "),n("a",_,[e("方法注入（Method Injection）"),s(a)]),e("。")]),w,n("p",null,[e("WebSocket作用域与WebSocket会话的生命周期相关联，适用于基于WebSocket的STOMP应用程序， 详情参阅："),n("a",T,[e("WebSocket作用域"),s(a)])]),C])}const j=o(i,[["render",P],["__file","beans-scope.html.vue"]]),R=JSON.parse('{"path":"/spring-framework/core/beans-scope.html","title":"Bean作用域（Scope）","lang":"zh-CN","frontmatter":{"title":"Bean作用域（Scope）","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-04-03T00:00:00.000Z","category":"Spring","tag":"Spring Framework","description":"Bean作用域（Scope） 当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。 你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强...","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/spring-framework/core/beans-scope.html"}],["meta",{"property":"og:site_name","content":"极客空间"}],["meta",{"property":"og:title","content":"Bean作用域（Scope）"}],["meta",{"property":"og:description","content":"Bean作用域（Scope） 当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。 你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.geekyspace.cn/pictures/2024/singleton.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-07T06:30:41.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"Spring Framework"}],["meta",{"property":"article:published_time","content":"2024-04-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-07T06:30:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Bean作用域（Scope）\\",\\"image\\":[\\"http://img.geekyspace.cn/pictures/2024/singleton.png\\",\\"http://img.geekyspace.cn/pictures/2024/prototype.png\\"],\\"datePublished\\":\\"2024-04-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-07T06:30:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[{"level":2,"title":"单例作用域（singleton）","slug":"单例作用域-singleton","link":"#单例作用域-singleton","children":[]},{"level":2,"title":"原型作用域（prototype）","slug":"原型作用域-prototype","link":"#原型作用域-prototype","children":[]},{"level":2,"title":"单例Bean与原型Bean依赖","slug":"单例bean与原型bean依赖","link":"#单例bean与原型bean依赖","children":[]},{"level":2,"title":"请求、会话、应用程序和WebSocket作用域","slug":"请求、会话、应用程序和websocket作用域","link":"#请求、会话、应用程序和websocket作用域","children":[{"level":3,"title":"初始Web配置","slug":"初始web配置","link":"#初始web配置","children":[]},{"level":3,"title":"Request Scope","slug":"request-scope","link":"#request-scope","children":[]},{"level":3,"title":"Session Scope","slug":"session-scope","link":"#session-scope","children":[]},{"level":3,"title":"Application Scope","slug":"application-scope","link":"#application-scope","children":[]},{"level":3,"title":"WebSocket Scope","slug":"websocket-scope","link":"#websocket-scope","children":[]},{"level":3,"title":"Bean Scope作为依赖项","slug":"bean-scope作为依赖项","link":"#bean-scope作为依赖项","children":[]}]},{"level":2,"title":"自定义作用域","slug":"自定义作用域","link":"#自定义作用域","children":[{"level":3,"title":"创建自定义 Scope","slug":"创建自定义-scope","link":"#创建自定义-scope","children":[]},{"level":3,"title":"使用自定义 Scope","slug":"使用自定义-scope","link":"#使用自定义-scope","children":[]}]}],"git":{"createdTime":1712131991000,"updatedTime":1712471441000,"contributors":[{"name":"zhouyu","email":"zhouyu@liquido.cn","commits":8}]},"readingTime":{"minutes":9.24,"words":2771},"filePathRelative":"spring-framework/core/beans-scope.md","localizedDate":"2024年4月3日","excerpt":"\\n<p>当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。\\n将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。</p>\\n<p>你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。\\n这种方法是强大且灵活的，因为你可以通过配置选择创建的对象的作用域，而不必在Java类级别上固定对象的作用域。\\nBean定义可以是多种作用域之一。Spring框架支持六种作用域，其中四种仅在使用Web感知（aware）的<code>ApplicationContext</code>时才可用。\\n你还可以创建<a href=\\"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">自定义作用域</a>。</p>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{j as comp,R as data};
