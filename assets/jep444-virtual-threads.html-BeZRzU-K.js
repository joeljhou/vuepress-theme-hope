import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e as o,a,b as s,d as e,o as i,r as c}from"./app-DVRWpGtU.js";const r={},u={href:"https://openjdk.org/projects/loom/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://go.dev/tour/concurrency/1",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.erlang.org/docs/23/efficiency_guide/processes.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://wiki.haskell.org/Lightweight_concurrency",target:"_blank",rel:"noopener noreferrer"},m={href:"https://openjdk.org/projects/loom/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html",target:"_blank",rel:"noopener noreferrer"};function h(b,n){const t=c("ExternalLinkIcon");return i(),l("div",null,[n[24]||(n[24]=o(`<h1 id="java-21-新特性-虚拟线程-virtual-threads" tabindex="-1"><a class="header-anchor" href="#java-21-新特性-虚拟线程-virtual-threads"><span>Java 21 新特性：虚拟线程（Virtual Threads）</span></a></h1><p>Java 21 引入了<strong>虚拟线程</strong>（Virtual Threads）功能，类似于Go语言中的<code>Goroutines</code>。 虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。</p><p>Java平台目前为止有两种类型的线程：<strong>传统线程</strong>，也称为<mark>平台线程</mark>，和<strong>虚拟线程</strong>。</p><h2 id="平台线程" tabindex="-1"><a class="header-anchor" href="#平台线程"><span>平台线程</span></a></h2><p>在引入虚拟线程之前，我们所使用的线程<code>java.lang.Thread</code>是由所谓的平台线程支持的。</p><p>这些线程通常是 1:1 映射到操作系统线程的，因此它们是重量级的，创建和销毁线程的开销很大。 且每个请求都需要一个独立的线程，这会导致线程资源的快速耗尽，从而限制了应用程序的可伸缩性。</p><h3 id="创建平台线程" tabindex="-1"><a class="header-anchor" href="#创建平台线程"><span>创建平台线程</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 由平台线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8)),a("p",null,[n[1]||(n[1]=s("随着")),a("a",u,[n[0]||(n[0]=s("Project Loom")),e(t)]),n[2]||(n[2]=s("简化了新的并发方法，它还提供了一种新的方法来创建平台支持的线程："))]),n[25]||(n[25]=o(`<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofPlatform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      
<span class="token comment">// 或者</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofPlatform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                      <span class="token punctuation">.</span><span class="token function">daemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;platform-thread&quot;</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">unstarted</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="虚拟线程" tabindex="-1"><a class="header-anchor" href="#虚拟线程"><span>虚拟线程</span></a></h2><p>虚拟线程是JDK提供的<strong>轻量级线程</strong>实现，可以在同一个OS线程上运行许多虚拟线程。 虚拟线程为平台线程提供了一种更有效的替代方案，允许开发人员以显著降低的开销处理大量任务。 这些线程提供了与现有Java代码的兼容性和无缝迁移路径，从而从增强的性能和资源利用率中获益。</p><p>许多语言中都有某种形式的轻量级线程：</p>`,4)),a("ul",null,[a("li",null,[n[4]||(n[4]=s("Go语言的")),a("a",d,[n[3]||(n[3]=s("Goroutines")),e(t)])]),a("li",null,[n[6]||(n[6]=s("Erlang的")),a("a",k,[n[5]||(n[5]=s("Erlang Processes")),e(t)])]),a("li",null,[n[8]||(n[8]=s("Haskell的")),a("a",v,[n[7]||(n[7]=s("Haskell Threads")),e(t)])]),n[9]||(n[9]=a("li",null,"等等",-1))]),n[26]||(n[26]=o(`<h3 id="创建虚拟线程" tabindex="-1"><a class="header-anchor" href="#创建虚拟线程"><span>创建虚拟线程</span></a></h3><ol><li>使用<code>Thread.startVirtualThread()</code>方法创建虚拟线程：</li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 使用静态构建器方法</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">startVirtualThread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 由虚拟线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用<code>Thread.ofVirtual()</code>来创建，这里还可以设置一些属性，比如：线程名称等。具体如下代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> virtualThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;virtual-thread&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用<code>ExecutorService</code>创建虚拟线程：</li></ol><p>从Java 5开始，就推荐开发人员使用<code>ExecutorServices</code>而不是直接使用<code>Thread</code>类了。 现在，Java 21中引入了使用虚拟线程，所以也有了新的ExecutorService来适配，看看下面的例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10_000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span class="token comment">// executor.close() 被隐式调用, 然后 waits</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.使用<code>ThreadFactory</code>创建虚拟线程：</p><p>开发者还可以创建一个生成虚拟线程的工厂来管理，具体看下面的例子例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ThreadFactory</span> virtualThreadFactory <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;virtual-thread&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Thread</span> factoryThread <span class="token operator">=</span> virtualThreadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 由虚拟线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
factoryThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码创建了一个虚拟线程工厂，每个虚拟线程都会以<code>virtual-thread</code>为前缀、以数字结尾（从0开始累加）的名称。</p><h2 id="虚拟线程如何工作" tabindex="-1"><a class="header-anchor" href="#虚拟线程如何工作"><span>虚拟线程如何工作</span></a></h2>`,13)),a("p",null,[n[11]||(n[11]=s("虚拟线程是一个新的轻量级")),n[12]||(n[12]=a("code",null,"java.lang.Thread",-1)),n[13]||(n[13]=s("变体，由JVM的")),a("a",m,[n[10]||(n[10]=s("Project Loom")),e(t)]),n[14]||(n[14]=s("项目实现的。 它使用了一种称为")),n[15]||(n[15]=a("code",null,"Continuation",-1)),n[16]||(n[16]=s("的技术，不受操作系统的管理或调度。相反，JVM负责调度。"))]),n[27]||(n[27]=a("figure",null,[a("img",{src:"https://img.geekyspace.cn/pictures/2024/202403141847457.jpg",alt:"Java中虚拟线程的结构",tabindex:"0",loading:"lazy"}),a("figcaption",null,"Java中虚拟线程的结构")],-1)),n[28]||(n[28]=a("p",null,"应用程序实例化虚拟线程，而 JVM 分配计算资源来处理它们。 与传统线程相对比，传统线程直接映射到操作系统（OS）进程。 传统线程中，应用程序代码负责提供和释放 OS 资源。 而虚拟线程中，应用程序实例化虚拟线程，从而表达并发需求。 但实际上是 JVM 从操作系统获取并释放资源。",-1)),n[29]||(n[29]=a("figure",null,[a("img",{src:"https://img.geekyspace.cn/pictures/2024/202403141846557.webp",alt:"JVM/OS线程管理",tabindex:"0",loading:"lazy"}),a("figcaption",null,"JVM/OS线程管理")],-1)),a("p",null,[n[18]||(n[18]=s("所需的平台线程在 FIFO 工作窃取 ")),a("a",g,[n[17]||(n[17]=s("ForkJoinPool")),e(t)]),n[19]||(n[19]=s(" 中进行管理，默认情况下使用所有可用处理器， 但可以通过调整系统属性 ")),n[20]||(n[20]=a("code",null,"jdk.virtualThreadScheduler.parallelism",-1)),n[21]||(n[21]=s(" 来根据您的需求进行修改。 您熟悉的 ")),n[22]||(n[22]=a("code",null,"ForkJoinPool",-1)),n[23]||(n[23]=s(" 和其他功能（如并行流）使用的公共池的主要区别在于，公共池以 LIFO 模式运行。"))])])}const T=p(r,[["render",h],["__file","jep444-virtual-threads.html.vue"]]),y=JSON.parse('{"path":"/md/java-features/Java21/jep444-virtual-threads.html","title":"Java 21 新特性：虚拟线程","lang":"zh-CN","frontmatter":{"title":"Java 21 新特性：虚拟线程","description":"Java 21 新特性：虚拟线程（Virtual Threads） Java 21 引入了虚拟线程（Virtual Threads）功能，类似于Go语言中的Goroutines。 虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。 Java平台目前为止有两种类型的线程：传统线程，也称为平台线程，和虚拟线程。...","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-01-11T00:00:00.000Z","category":"Java","tag":"Java Features","order":444,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java-features/Java21/jep444-virtual-threads.html"}],["meta",{"property":"og:title","content":"Java 21 新特性：虚拟线程"}],["meta",{"property":"og:description","content":"Java 21 新特性：虚拟线程（Virtual Threads） Java 21 引入了虚拟线程（Virtual Threads）功能，类似于Go语言中的Goroutines。 虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。 Java平台目前为止有两种类型的线程：传统线程，也称为平台线程，和虚拟线程。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/202403141847457.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-27T17:14:35.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"Java Features"}],["meta",{"property":"article:published_time","content":"2024-01-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T17:14:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 21 新特性：虚拟线程\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/202403141847457.jpg\\",\\"https://img.geekyspace.cn/pictures/2024/202403141846557.webp\\"],\\"datePublished\\":\\"2024-01-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-27T17:14:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[{"level":2,"title":"平台线程","slug":"平台线程","link":"#平台线程","children":[{"level":3,"title":"创建平台线程","slug":"创建平台线程","link":"#创建平台线程","children":[]}]},{"level":2,"title":"虚拟线程","slug":"虚拟线程","link":"#虚拟线程","children":[{"level":3,"title":"创建虚拟线程","slug":"创建虚拟线程","link":"#创建虚拟线程","children":[]}]},{"level":2,"title":"虚拟线程如何工作","slug":"虚拟线程如何工作","link":"#虚拟线程如何工作","children":[]}],"git":{"createdTime":1719508475000,"updatedTime":1719508475000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":3.57,"words":1070},"filePathRelative":"md/java-features/Java21/jep444-virtual-threads.md","localizedDate":"2024年1月11日","excerpt":"\\n<p>Java 21 引入了<strong>虚拟线程</strong>（Virtual Threads）功能，类似于Go语言中的<code>Goroutines</code>。\\n虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。</p>\\n<p>Java平台目前为止有两种类型的线程：<strong>传统线程</strong>，也称为<mark>平台线程</mark>，和<strong>虚拟线程</strong>。</p>\\n<h2>平台线程</h2>\\n<p>在引入虚拟线程之前，我们所使用的线程<code>java.lang.Thread</code>是由所谓的平台线程支持的。</p>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{T as comp,y as data};
