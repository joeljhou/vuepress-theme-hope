import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as c,c as i,a as n,b as t,d as s,e as a}from"./app-cwTBpMHt.js";const l={},r=a('<h1 id="类文件结构" tabindex="-1"><a class="header-anchor" href="#类文件结构"><span>类文件结构</span></a></h1><blockquote><p>计算机只能运行由0和1构成的二进制格式。 要运行Java程序，必须先通过Java虚拟机（JVM）执行编译后的Java代码，这个编译后的代码就是<strong>Java字节码</strong>，存储在<code>.class</code>类文件中。</p></blockquote><h2 id="跨平台的基石" tabindex="-1"><a class="header-anchor" href="#跨平台的基石"><span>跨平台的基石</span></a></h2><p>Java字节码具有“平台无关性”和“语言无关性”。</p><ul><li><strong>平台无关性：</strong> 字节码可以在任何支持JVM的平台上运行，实现“一次编写，到处运行”</li><li><strong>语言无关性：</strong> 多种编程语言可以编译成字节码并在JVM（GraalVM）上运行，不仅限于Java</li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/202407200209120.png" alt="Java虚拟机提供的语言无关性" tabindex="0" loading="lazy"><figcaption>Java虚拟机提供的语言无关性</figcaption></figure><h2 id="class类文件结构-理论" tabindex="-1"><a class="header-anchor" href="#class类文件结构-理论"><span>Class类文件结构（理论）</span></a></h2><p>Java技术的良好向后兼容性得益于Class文件结构的稳定性， 每个Class文件对应一个类或接口的定义信息，是一组以8个字节为单位的二进制流。各数据项严格按顺序排列，没有任何分隔符。</p><p>Class文件格式类似于C语言的结构体，这种伪结构只有两种数据类型：“无符号数”和“表”。</p><ul><li><strong>无符号数：</strong> 基本数据类型，使用<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>表示1、2、4、8个字节的无符号数。 它们可以描述数字、索引引用、数量值或按照<code>UTF-8</code>编码的字符串值。</li><li><strong>表：</strong> 由多个无符号数或其他表构成的复合数据类型，通常以“_info”结尾。 表用于描述有层次关系的复合结构，整个Class文件本质上也是一个表，由按严格顺序排列的数据项构成。</li></ul>',10),p={href:"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html",target:"_blank",rel:"noopener noreferrer"},u=n("code",null,"ClassFile",-1),m=a(`<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ClassFile</span> <span class="token punctuation">{</span>
  u4 magic<span class="token punctuation">;</span>                   <span class="token comment">// 魔数 (0xCAFEBABE)，标识class文件格式</span>
  u2 minor_version<span class="token punctuation">;</span>           <span class="token comment">// 次版本号</span>
  u2 major_version<span class="token punctuation">;</span>           <span class="token comment">// 主版本号</span>
  u2 constant_pool_count<span class="token punctuation">;</span>     <span class="token comment">// 常量池计数</span>
  cp_info constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 常量池</span>
  u2 access_flags<span class="token punctuation">;</span>            <span class="token comment">// 访问标志</span>
  u2 this_class<span class="token punctuation">;</span>              <span class="token comment">// 当前类索引</span>
  u2 super_class<span class="token punctuation">;</span>             <span class="token comment">// 父类索引</span>
  u2 interfaces_count<span class="token punctuation">;</span>        <span class="token comment">// 接口计数</span>
  u2 interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 接口索引表</span>
  u2 fields_count<span class="token punctuation">;</span>            <span class="token comment">// 字段计数</span>
  field_info fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 字段表</span>
  u2 methods_count<span class="token punctuation">;</span>           <span class="token comment">// 方法计数</span>
  method_info methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 方法表</span>
  u2 attributes_count<span class="token punctuation">;</span>        <span class="token comment">// 属性计数</span>
  attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 属性表</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过分析 ClassFile 的内容，我们便可以知道 class 文件的组成。</p><figure><img src="https://img.geekyspace.cn/pictures/2024/202407220149546.png" alt="ClassFile 内容分析" tabindex="0" loading="lazy"><figcaption>ClassFile 内容分析</figcaption></figure><h3 id="魔数" tabindex="-1"><a class="header-anchor" href="#魔数"><span>魔数</span></a></h3><p>魔数是头4个字节的值<code>0xCAFEBABE</code>，用于验证文件是否为有效的Class文件。 不仅限于Class文件，很多文件格式如<code>GIF</code>或<code>JPEG</code>等也使用魔数来进行身份识别。</p><ul><li>GIF文件：<code>47 49 46 38</code></li><li>JPEG文件：<code>FF D8 FF E0</code></li></ul><p>在Java被称为“Oak”语言时期（大约1991年前后），<code>0xCAFEBABE</code>被选为魔数。 Java开发小组关键成员Patrick Naughton提到，他们选择这个值是因为它好玩且容易记忆， 象征着著名咖啡品牌Peet’s Coffee深受欢迎的Baristas咖啡，也预示着日后“Java”这一商标名称的出现。</p><h3 id="class文件版本号" tabindex="-1"><a class="header-anchor" href="#class文件版本号"><span>Class文件版本号</span></a></h3><p>紧跟魔数<code>0xCAFEBABE</code>之后的4个字节存储的是Class文件的版本号，其中：</p><ul><li>第5~6字节：次版本号（Minor Version）</li><li>第7~8字节：主版本号（Major Version），Java 8 = 52.0</li></ul><p>Java的主版本号从JDK 1.0的45开始，每次大版本发布都会+1； 次版本号通常保持为0，对应一些次要的特性改进或修复。</p><p><strong>Java版本对应表：</strong></p><table><thead><tr><th>JDK版本</th><th>十进制</th><th>十六进制</th><th>发布时间</th></tr></thead><tbody><tr><td>JDK1.1</td><td>45</td><td>0x2D</td><td>1996-05-15</td></tr><tr><td>JDK1.2</td><td>46</td><td>0x2E</td><td>1998-12-08</td></tr><tr><td>JDK1.3</td><td>47</td><td>0x2F</td><td>2000-05-08</td></tr><tr><td>JDK1.4</td><td>48</td><td>0x30</td><td>2002-02-13</td></tr><tr><td>JDK1.5</td><td>49</td><td>0x31</td><td>2004-09-30</td></tr><tr><td>JDK1.6</td><td>50</td><td>0x32</td><td>2006-12-11</td></tr><tr><td>JDK1.7</td><td>51</td><td>0x33</td><td>2011-07-28</td></tr><tr><td>JDK1.8</td><td>52</td><td>0x34</td><td>2014-03-18</td></tr><tr><td>Java9</td><td>53</td><td>0x35</td><td>2017-09-21</td></tr><tr><td>Java10</td><td>54</td><td>0x36</td><td>2018-03-20</td></tr><tr><td>Java11</td><td>55</td><td>0x37</td><td>2018-09-25</td></tr><tr><td>Java12</td><td>56</td><td>0x38</td><td>2019-03-19</td></tr><tr><td>Java13</td><td>57</td><td>0x39</td><td>2019-09-17</td></tr><tr><td>Java14</td><td>58</td><td>0x3A</td><td>2020-03-17</td></tr><tr><td>Java15</td><td>59</td><td>0x3B</td><td>2020-09-15</td></tr><tr><td>Java16</td><td>60</td><td>0x3C</td><td>2021-03-16</td></tr><tr><td>Java17</td><td>61</td><td>0x3D</td><td>2021-09-14</td></tr><tr><td>Java18</td><td>62</td><td>0x3E</td><td>2022-03-22</td></tr><tr><td>Java19</td><td>63</td><td>0x3F</td><td>2022-09-20</td></tr><tr><td>Java20</td><td>64</td><td>0x40</td><td>2023-03-21</td></tr><tr><td>Java21</td><td>65</td><td>0x41</td><td>2023-09-19</td></tr><tr><td>Java22</td><td>66</td><td>0x42</td><td>2024-03-19</td></tr></tbody></table><h3 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池"><span>常量池</span></a></h3><p>常量池入口紧随主、次版本号之后，可以理解成Class文件的资源仓库。 与其他数据关联最多，占用空间最大，也是第一个出现的表类型数据项<code>cp_info</code>。</p><p><strong>1、常量池计数</strong></p><p>由于常量项不固定，入口处<code>u2</code>类型的数据值表示<strong>常量池计数</strong>（<code>constant_pool_count</code>）。</p><ul><li>常量池的计数从1开始，即：<code>常量项 = 常量池计数 - 1</code></li><li>Class文件格式规范刻意将第0项常量空出，索引值0表示“不引用任何常量池项”</li></ul><p><strong>2、常量类型</strong></p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p><ul><li><strong>字面量：</strong> 比较接近于Java语言层面的常量概念，如数值、文本字符串、final常量等</li><li><strong>符号引用：</strong> 符号引用则属于编译原理方面的概念，包括以下几类常量： <ul><li>被模块导出或者开放的包(Package)</li><li>类和接口的全限定名(Fully Qualified Name)</li><li>字段的名称和描述符(Descriptor)</li><li>方法的名称和描述符</li><li>方法句柄和方法类型(Method Handle、Method Type、Invoke Dynamic)</li><li>动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)</li></ul></li></ul><p>不同于C/C++编译时有“连接”步骤，JVM在加载Class文件时才进行“动态连接”。 因此，Class文件不保存方法、字段最终在内存中的布局信息。 JVM在类加载时从常量池获取符号引用，并在类创建或运行时解析为具体地址。</p><p><strong>3、常量表结构</strong></p>`,23),v={href:"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html#jvms-4.4",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"constant_pool",-1),k=a(`<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>cp_info <span class="token punctuation">{</span>
  u1 tag<span class="token punctuation">;</span>
  u1 info<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常量池中的每项常量都是一个表，起始的第一位是一个<code>u1</code>类型的标志位（tag），表示当前常量的类型。</p><ol><li>最初设计的11种常量类型</li><li>为支持动态语言，增加了4种动态语言相关的常量</li><li>为支持Java模块化系统（Jigsaw），新增了<code>CONSTANT_Module_info</code>和<code>CONSTANT_Package_info</code></li></ol><table><thead><tr><th>类型(tag)</th><th>描述</th><th>结构细节（起始<code>u1 tag;</code>）</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info(1)</td><td>UTF-8编码的字符串</td><td><code>u2 length;</code><br>字符串的字节长度<br><code>u1 bytes[length];</code><br>UTF-8编码的字节数据</td></tr><tr><td>CONSTANT_Integer_info(3)</td><td>整型字面量</td><td><code>u4 bytes;</code> 32位整数值</td></tr><tr><td>CONSTANT_Float_info(4)</td><td>浮点型字面量</td><td><code>u4 bytes;</code> 32位浮点数值</td></tr><tr><td>CONSTANT_Long_info(5)</td><td>长整型字面量</td><td><code>u4 high_bytes;</code> 高32位<br><code>u4 low_bytes;</code> 低32位</td></tr><tr><td>CONSTANT_Double_info(6)</td><td>双精度浮点型字面量</td><td><code>u4 high_bytes;</code> 高32位<br><code>u4 low_bytes;</code> 低32位</td></tr><tr><td>CONSTANT_Class_info(7)</td><td>类或接口的符号引用</td><td><code>u2 name_index;</code><br>指向类或接口名称的索引</td></tr><tr><td>CONSTANT_String_info(8)</td><td>字符串类型字面量</td><td><code>u2 string_index;</code><br>指向字符串字面量的索引</td></tr><tr><td>CONSTANT_Fieldref_info(9)</td><td>字段的符号引用</td><td><code>u2 class_index;</code><br>指向字段所在类的索引<br><code>u2 name_and_type_index;</code><br>指向字段名称和描述符的索引</td></tr><tr><td>CONSTANT_Methodref_info(10)</td><td>类中方法的符号引用</td><td><code>u2 class_index;</code><br>指向方法所在类的索引<br><code>u2 name_and_type_index;</code><br>指向方法名称和描述符的索引</td></tr><tr><td>CONSTANT_InterfaceMethodref_info(11)</td><td>接口中方法的符号引用</td><td><code>u2 class_index;</code><br>指向接口所在类的索引<br><code>u2 name_and_type_index;</code><br>指向方法名称和描述符的索引</td></tr><tr><td>CONSTANT_NameAndType_info(12)</td><td>字段或方法的部分符号引用</td><td><code>u2 name_index;</code><br>指向字段或方法名称的索引<br><code>u2 descriptor_index;</code><br>指向字段或方法描述符的索引</td></tr><tr><td>CONSTANT_MethodHandle_info(15)</td><td>表示方法句柄</td><td><code>u1 reference_kind;</code><br>方法句柄的类型<br><code>u2 reference_index;</code><br>指向方法句柄引用的索引</td></tr><tr><td>CONSTANT_MethodType_info(16)</td><td>表示方法类型</td><td><code>u2 descriptor_index;</code><br>指向方法类型描述符的索引</td></tr><tr><td>CONSTANT_Dynamic_info(17)</td><td>表示一个动态计算常量</td><td><code>u2 bootstrap_method_attr_index;</code><br>指向引导方法属性的索引<br><code>u2 name_and_type_index;</code><br>指向名称和描述符的索引</td></tr><tr><td>CONSTANT_InvokeDynamic_info(18)</td><td>表示一个动态方法调用点</td><td><code>u2 bootstrap_method_attr_index;</code><br>指向引导方法属性的索引<br><code>u2 name_and_type_index;</code><br>指向名称和描述符的索引</td></tr><tr><td>CONSTANT_Module_info(19)</td><td>表示一个模块</td><td><code>u2 name_index;</code><br>指向模块名称的索引</td></tr><tr><td>CONSTANT_Package_info(20)</td><td>表示一个模块中开放或者导出的包</td><td><code>u2 name_index;</code><br>指向包名称的索引</td></tr></tbody></table><p>常量池的数据结构复杂，因为包含17种独立的常量类型，彼此没有共性，因此需要逐项讲解。</p><h3 id="访问标志" tabindex="-1"><a class="header-anchor" href="#访问标志"><span>访问标志</span></a></h3><p>在常量池结束后，紧接的2个字节代表访问标志（<code>access_flags</code>），用于识别类或接口的访问信息，包括：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 <code>public</code> 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 <code>final</code>，只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 <code>invokespecial</code> 字节码指令的新语义，<code>invokespecial</code> 指令的语义在 JDK 1.0.2 发生过改变，为了区别该指令使用哪种语义，JDK 1.0.2 之后编译出来的类的这个标志都必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 <code>abstract</code> 类型，对于接口或抽象类来说，此标志值为真，其他类型值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标识这是一个模块</td></tr></tbody></table><p>总共有 16 个标记位可供使用，但常用的只有其中 7 个，见下图：</p><figure><img src="https://img.geekyspace.cn/pictures/2024/202407230642248.png" alt="16个访问标记位" tabindex="0" loading="lazy"><figcaption>16个访问标记位</figcaption></figure><h3 id="类索引、父类索引与接口索引集合" tabindex="-1"><a class="header-anchor" href="#类索引、父类索引与接口索引集合"><span>类索引、父类索引与接口索引集合</span></a></h3><p>在Java类文件结构中，类索引、父类索引和接口索引集合用于确定类的继承和实现关系。</p><ul><li><strong>类索引（<code>this_class</code>）：</strong> 确定当前类的全限定名</li><li><strong>父类索引（<code>super_class</code>）：</strong> 确定当前类的父类的全限定名 <ul><li>类索引和父类索引都是<code>u2</code>类型的索引值，指向<code>CONSTANT_Class_info</code>常量</li><li>再通过<code>CONSTANT_Class_info</code>常量中的索引值，找到定义在<code>CONSTANT_Utf8_info</code>中的全限定名字符串</li></ul></li><li><strong>接口索引集合（<code>interfaces</code>）：</strong> 描述当前类实现的所有接口 <ul><li>接口索引集合是一个数组，首项为<code>u2</code>类型的接口计数器（<code>interfaces_count</code>）</li><li>接口计数器值为0时，后面的接口索引表不占用任何字节，否则每个索引指向常量池中的一个<code>CONSTANT_Class_info</code>类型的接口名称</li></ul></li></ul><h3 id="字段表集合" tabindex="-1"><a class="header-anchor" href="#字段表集合"><span>字段表集合</span></a></h3><p>字段表（<code>field_info</code>）用于描述接口或者类中声明的变量。</p>`,15),h={href:"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html#jvms-4.5",target:"_blank",rel:"noopener noreferrer"},g=a(`<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>field_info <span class="token punctuation">{</span>
  u2             access_flags<span class="token punctuation">;</span>
  u2             name_index<span class="token punctuation">;</span>
  u2             descriptor_index<span class="token punctuation">;</span>
  u2             attributes_count<span class="token punctuation">;</span>
  attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>1、字段访问标志（<code>access_flags</code>）</strong></p><p>与类中的<code>access_flags</code>类似，都是一个<code>u2</code>的数据类型，取值如下表：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否 <code>public</code></td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否 <code>private</code></td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否 <code>protected</code></td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否 <code>static</code></td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否 <code>final</code></td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否 <code>volatile</code></td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否 <code>transient</code></td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否 <code>enum</code></td></tr></tbody></table><p>受Java语法规则的约束：</p><ul><li><code>public</code>、<code>private</code>、<code>protected</code> 只能三选一</li><li><code>final</code>、<code>volatile</code>不能同时选择</li><li>接口中的字段必须有 <code>public</code>、<code>static</code>和<code>final</code></li></ul><p><strong>2、简单名称（<code>name_index</code>）和描述符（<code>descriptor_index</code>）</strong></p><p>跟随<code>access_flags</code>标志之后的两项索引值；以及<strong>全限定名</strong>这三种特殊字符串的概念解释：</p><ul><li>全限定名：表示字段或方法在类中的完整路径，包括包名和类名。例如<code>java.lang.String</code></li><li>简单名称：表示字段或方法的名称。例如<code>name</code>是字段的简单名称，<code>toString</code>是方法的简单名称</li><li>描述符：表示字段或方法的类型信息 <ul><li>对于字段，描述符表示字段的类型，例如<code>I</code>表示<code>int</code>类型</li><li>对于方法，描述符表示方法的参数和返回类型，例如<code>(I)V</code>表示接受<code>int</code>参数且无返回值的方法</li></ul></li></ul><p><strong>描述符标识字符含义</strong></p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型 <code>byte</code></td></tr><tr><td>C</td><td>基本类型 <code>char</code></td></tr><tr><td>D</td><td>基本类型 <code>double</code></td></tr><tr><td>F</td><td>基本类型 <code>float</code></td></tr><tr><td>I</td><td>基本类型 <code>int</code></td></tr><tr><td>J</td><td>基本类型 <code>long</code></td></tr><tr><td>S</td><td>基本类型 <code>short</code></td></tr><tr><td>Z</td><td>基本类型 <code>boolean</code></td></tr><tr><td>V</td><td>特殊类型 <code>void</code></td></tr><tr><td>L</td><td>对象类型，例如 <code>Ljava/lang/Object;</code></td></tr></tbody></table><p><strong>3、属性表集合</strong></p><p>Class文件、字段表、和方法表都包含各自的属性表集合，用于记录特定场景下的附加信息。 每个属性表集合由属性计数（<code>attributes_count</code>）和若干属性信息（<code>attribute_info</code>）组成。</p><ul><li><strong>属性计数 (<code>attributes_count</code>)：</strong> 表示该集合中包含的属性个数</li><li><strong>属性信息 (<code>attribute_info</code>)：</strong> 每个属性的信息结构，提供详细的元数据</li></ul><h3 id="方法表集合" tabindex="-1"><a class="header-anchor" href="#方法表集合"><span>方法表集合</span></a></h3><p>方法表（<code>method_info</code>）用于描述类或接口中声明的方法。</p>`,16),_={href:"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html#jvms-4.6",target:"_blank",rel:"noopener noreferrer"},C=a(`<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>method_info <span class="token punctuation">{</span>
    u2             access_flags<span class="token punctuation">;</span>
    u2             name_index<span class="token punctuation">;</span>
    u2             descriptor_index<span class="token punctuation">;</span>
    u2             attributes_count<span class="token punctuation">;</span>
    attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>1、方法访问标志（<code>access_flags</code>）</strong></p><ul><li>去除<code>volatile</code>和<code>transient</code>关键字，不能修饰方法</li><li>新增<code>synchronized</code>、<code>native</code>、<code>strictfp</code>和<code>abstract</code>关键字</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否为 <code>public</code></td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否为 <code>private</code></td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否为 <code>protected</code></td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否为 <code>static</code></td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否为 <code>final</code></td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为 <code>synchronized</code></td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为 <code>native</code></td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为 <code>abstract</code></td></tr><tr><td>ACC_STRICT</td><td>0x0800</td><td>方法是否为 <code>strictfp</code></td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生</td></tr></tbody></table><p><strong>2、方法的代码<code>Code</code></strong></p><p>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚。 而方法的代码，经过<code>javac</code>编译成<a href="/md/jvm/basics/bytecode">字节码指令</a>后存放在<strong>方法属性表集合</strong>中的<code>Code</code>的属性中。</p><h3 id="属性表集合" tabindex="-1"><a class="header-anchor" href="#属性表集合"><span>属性表集合</span></a></h3><p>Class文件、字段表、和方法表都包含各自的属性表集合，用于记录特定场景下的附加信息。</p><p><strong>虚拟机规范预定义的属性</strong></p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>由<code>final</code>关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>被声明为<code>deprecated</code>的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才可能拥有此属性，用于标示此类存在的外部方法</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java代码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量信息</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK6新增属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>JDK5新增属性，用于支持泛型标记下的方法签名。在 Java 语言中，任何类、接口、初始化方法或成员的字段如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会记录泛型签名信息。由于 Java 的泛型采用擦除实现，为了能够在泛型擦除后还能确保签名信息，可以通过 Signature 属性记录泛型签名相关信息</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>JDK5新增属性，用于存储额外的调试信息。譬如如在 JSP 文件调试时，无法通过 Java 推栈来推导到 JSP 文件的代码。JSR 45 提议的运行时通过插桩机制向虚拟机中的程序提供了一种进行调试的标准机制，使用该属性可以用于存储插桩时额外新增的调试信息</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>标示为编译器自动生成的代码</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>JDK5新增属性，使用扩展的签名标示符，是为了引入泛型方法之后能描述泛型参数的类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5新增属性，为动态注解提供支持。该属性用于指明哪些注解是在运行时（实际在运行时就意味着反射调用）可见的</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5新增属性，与 RuntimeVisibleAnnotations 属性作用相反，用于指明哪些注解是在运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>JDK5新增属性，作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法参数</td></tr><tr><td>RuntimeInvisibleParameterAnnotations</td><td>方法表</td><td>JDK5新增属性，作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象为方法参数</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>JDK5新增属性，用于记录注解类型元素默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>JDK7新增属性，用于保存 invokedynamic 指令引用的引导方法限定符</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表、Code 属性</td><td>JDK8新增属性，为实现 JSR 308 中新增的类型注解提供的支持。用于指明哪些注解是在运行时（实际在运行时意味着反射调用）可见的</td></tr><tr><td>RuntimeInvisibleTypeAnnotations</td><td>类、方法表、字段表、Code 属性</td><td>JDK8新增属性，为实现 JSR 308 中新增的类型注解提供的支持。与 RuntimeVisibleTypeAnnotations 属性作用相反，用于指明哪些注解是在运行时不可见的</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>JDK8新增属性，用于支持（编译时加上 -parameters 参数）将方法参数名称保存进 Class 文件中，并可运行时获取此数据。此数据可用于方法参数名称（典型的如 IDE 的代码提示）只能通过 Javadoc 中得到</td></tr><tr><td>Module</td><td>类</td><td>JDK9新增属性，用于记录一个 Module 的名称以及相关信息（requires、exports、opens、uses、provides）</td></tr><tr><td>ModulePackages</td><td>类</td><td>JDK9新增属性，用于记录一个模块中所有存在 exports 或者 opens 的包</td></tr><tr><td>ModuleMainClass</td><td>类</td><td>JDK9新增属性，用于指定一个模块的主类</td></tr><tr><td>NestHost</td><td>类</td><td>JDK11新增属性，用于支持嵌套类（Java中的内部类）的成员和访问控制的 API。——宿主类通过此属性知道自己有哪些内部类</td></tr><tr><td>NestMembers</td><td>类</td><td>JDK11新增属性，用于支持嵌套类（Java中的内部类）的成员和访问控制的 API。——宿主类通过此属性知道自己有哪些内部类</td></tr></tbody></table>`,10),f={href:"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html#jvms-4.7",target:"_blank",rel:"noopener noreferrer"},x=a(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>attribute_info <span class="token punctuation">{</span>
    u2 attribute_name_index<span class="token punctuation">;</span>
    u4 attribute_length<span class="token punctuation">;</span>
    u1 info<span class="token punctuation">[</span>attribute_length<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个属性，其名称从常量池中引用1个<code>CONSTANT_Utf8_info</code>表示， 通过1个<code>u4</code>的<code>attribute_length</code>说明属性值的字节数，属性值的结构完全自定义。</p><ol><li>Code属性</li><li>Exceptions属性</li><li>LineNumberTable属性</li><li>LocalVariableTable及LocalVariableTypeTable属性</li><li>SourceFile及SourceDebugExtension属性</li><li>ConstantValue属性</li><li>InnerClasses属性</li><li>Deprecated及Synthetic属性</li><li>StackMapTable属性</li><li>Signature属性</li><li>BootstrapMethods属性</li><li>MethodParameters属性</li><li>模块化相关属性</li><li>运行时注解相关属性</li></ol><h2 id="编译字节码分析-实践" tabindex="-1"><a class="header-anchor" href="#编译字节码分析-实践"><span>编译字节码分析（实践）</span></a></h2><p>使用<code>javac Main.java</code>命令，编译生成<code>Main.class</code>文件：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),A={href:"https://www.ghxi.com/winhex.html",target:"_blank",rel:"noopener noreferrer"},J=n("code",null,".class",-1),T=a(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>CA FE BA BE 00 00 00 3D 00 <span class="token number">13</span> 0A 00 02 00 03 07
00 04 0C 00 05 00 06 01 00 <span class="token number">10</span> 6A <span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> 2F 6C
<span class="token number">61</span> 6E <span class="token number">67</span> 2F 4F <span class="token number">62</span> 6A <span class="token number">65</span> <span class="token number">63</span> <span class="token number">74</span> 01 00 06 3C <span class="token number">69</span> 6E
<span class="token number">69</span> <span class="token number">74</span> 3E 01 00 03 <span class="token number">28</span> <span class="token number">29</span> <span class="token number">56</span> 09 00 08 00 09 07 00
0A 0C 00 0B 00 0C 01 00 04 4D <span class="token number">61</span> <span class="token number">69</span> 6E 01 00 01
6D 01 00 01 <span class="token number">49</span> 01 00 04 <span class="token number">43</span> 6F <span class="token number">64</span> <span class="token number">65</span> 01 00 0F 4C
<span class="token number">69</span> 6E <span class="token number">65</span> 4E <span class="token number">75</span> 6D <span class="token number">62</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">54</span> <span class="token number">61</span> <span class="token number">62</span> 6C <span class="token number">65</span> 01 00
03 <span class="token number">69</span> 6E <span class="token number">63</span> 01 00 03 <span class="token number">28</span> <span class="token number">29</span> <span class="token number">49</span> 01 00 0A <span class="token number">53</span> 6F <span class="token number">75</span>
<span class="token number">72</span> <span class="token number">63</span> <span class="token number">65</span> <span class="token number">46</span> <span class="token number">69</span> 6C <span class="token number">65</span> 01 00 09 4D <span class="token number">61</span> <span class="token number">69</span> 6E 2E 6A
<span class="token number">61</span> <span class="token number">76</span> <span class="token number">61</span> 00 <span class="token number">21</span> 00 08 00 02 00 00 00 01 00 02 00 
0B 00 0C 00 00 00 02 00 01 00 05 00 06 00 01 00
0D 00 00 00 1D 00 01 00 01 00 00 00 05 2A B7 00
01 B1 00 00 00 01 00 0E 00 00 00 06 00 01 00 00
00 01 00 01 00 0F 00 <span class="token number">10</span> 00 01 00 0D 00 00 00 1F
00 02 00 01 00 00 00 07 2A B4 00 07 04 <span class="token number">60</span> AC 00
00 00 01 00 0E 00 00 00 06 00 01 00 00 00 06 00
01 00 <span class="token number">11</span> 00 00 00 02 00 <span class="token number">12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>CA FE BA BE</code>：<strong>魔数</strong>，用于标识Class文件格式</li><li><code>00 00 00 3D</code>：<strong>版本号</strong>，其中<code>00 00</code>是次版本号，<code>00 3D</code>是主版本号（61，对应Java17）</li><li><code>00 13</code>：<strong>常量池计数</strong>，<code>0x13</code>十进制为19，第0项常量空出，因此常量池中有18个常量</li></ul><p>使用<code>javap -verbose Main</code>命令查看<strong>常量池</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Constant pool:
   <span class="token comment">#1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
   <span class="token comment">#2 = Class              #4             // java/lang/Object</span>
   <span class="token comment">#3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span>
   <span class="token comment">#4 = Utf8               java/lang/Object</span>
   <span class="token comment">#5 = Utf8               &lt;init&gt;</span>
   <span class="token comment">#6 = Utf8               ()V</span>
   <span class="token comment">#7 = Fieldref           #8.#9          // Main.m:I</span>
   <span class="token comment">#8 = Class              #10            // Main</span>
   <span class="token comment">#9 = NameAndType        #11:#12        // m:I</span>
  <span class="token comment">#10 = Utf8               Main</span>
  <span class="token comment">#11 = Utf8               m</span>
  <span class="token comment">#12 = Utf8               I</span>
  <span class="token comment">#13 = Utf8               Code</span>
  <span class="token comment">#14 = Utf8               LineNumberTable</span>
  <span class="token comment">#15 = Utf8               inc</span>
  <span class="token comment">#16 = Utf8               ()I</span>
  <span class="token comment">#17 = Utf8               SourceFile</span>
  <span class="token comment">#18 = Utf8               Main.java</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>00 21</code>：<strong>访问标志</strong>，<code>ACC_PUBLIC</code>（public）和<code>ACC_SUPER</code>（super）</li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/202407251001215.png" alt="类索引查找全限定名的过程" tabindex="0" loading="lazy"><figcaption>类索引查找全限定名的过程</figcaption></figure><ul><li><code>00 08</code>：<strong>类索引</strong>，指向常量池第8项<code>#8 = Class #10 // Main</code>，表示当前类是<code>Main</code></li><li><code>00 02</code>：<strong>父类索引</strong>，指向常量池第2项<code>#2 = Class #4 // java/lang/Object</code>，表示父类是<code>Object</code></li><li><code>00 00</code>：<strong>接口计数器</strong>，为0表示该类没有实现任何接口，所以<strong>接口索引集合</strong>为空</li><li><code>00 01</code>：<strong>字段计数器</strong>，表示有1个字段</li><li><code>00 02 00 0B 00 0C 00 00</code>: <strong>字段表集合</strong><ul><li><code>access_flags</code>：<code>00 02</code>表示<code>private</code>访问权限</li><li><code>name_index</code>：<code>00 0B</code>指向常量池中的第11项<code>#11 = Utf8 m</code>，表示字段名为<code>m</code></li><li><code>descriptor_index</code>：<code>00 0C</code>指向常量池中的第12项<code>#12 = Utf8 I</code>，表示字段类型为<code>int</code></li><li><code>attributes_count</code>：<code>00 00</code>表示没有属性，所以<code>attribute_info</code>为空</li></ul></li><li><code>00 02</code>：<strong>方法计数器</strong>，表示有2个方法</li></ul>`,7),y=n("code",null,"javap -verbose Main",-1),N=n("strong",null,"方法表集合",-1),j={href:"https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer",target:"_blank",rel:"noopener noreferrer"},S=a(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">{</span>
  public Main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V
    flags: <span class="token punctuation">(</span>0x0001<span class="token punctuation">)</span> ACC_PUBLIC
    Code:
      <span class="token assign-left variable">stack</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">locals</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span>: aload_0
         <span class="token number">1</span>: invokespecial <span class="token comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
         <span class="token number">4</span>: <span class="token builtin class-name">return</span>
      LineNumberTable:
        line <span class="token number">1</span>: <span class="token number">0</span>

  public int inc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>I
    flags: <span class="token punctuation">(</span>0x0001<span class="token punctuation">)</span> ACC_PUBLIC
    Code:
      <span class="token assign-left variable">stack</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">locals</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span>: aload_0
         <span class="token number">1</span>: getfield      <span class="token comment">#7                  // Field m:I</span>
         <span class="token number">4</span>: iconst_1
         <span class="token number">5</span>: iadd
         <span class="token number">6</span>: ireturn
      LineNumberTable:
        line <span class="token number">6</span>: <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),D={href:"https://coolshell.cn/articles/9229.html",target:"_blank",rel:"noopener noreferrer"};function M(E,V){const e=o("ExternalLinkIcon");return c(),i("div",null,[r,n("p",null,[n("a",p,[t("JVM虚拟机规范第四章"),s(e)]),t(" 中规定了Class文件必须是一个固定的"),u,t("结构，如下所示：")]),m,n("p",null,[n("a",v,[t("JVM虚拟机规范第四章-常量池"),s(e)]),t(" 定义了"),b,t("表条目具有以下通用格式：")]),k,n("p",null,[n("a",h,[t("JVM虚拟机规范第四章-字段表"),s(e)]),t(" 定义了结构：")]),g,n("p",null,[n("a",_,[t("JVM虚拟机规范第四章-方法表"),s(e)]),t(" 定义了结构，与属性表相似：")]),C,n("p",null,[n("a",f,[t("JVM虚拟机规范第四章-属性表"),s(e)]),t(" 定义了结构：")]),x,n("p",null,[t("使用"),n("a",A,[t("WinHex"),s(e)]),t("(十六进制编辑器) 打开"),J,t("文件查看：")]),T,n("p",null,[t("使用"),y,t("命令查看"),N,t("， 或使用"),n("a",j,[t("IDEA jclasslib插件"),s(e)]),t("查看：")]),S,n("p",null,[n("a",D,[t("酷 壳 – CoolShell《实例分析JAVA CLASS的文件结构》"),s(e)])])])}const O=d(l,[["render",M],["__file","class.html.vue"]]),B=JSON.parse('{"path":"/md/jvm/specs/class.html","title":"类文件结构","lang":"zh-CN","frontmatter":{"title":"类文件结构","description":"类文件结构 计算机只能运行由0和1构成的二进制格式。 要运行Java程序，必须先通过Java虚拟机（JVM）执行编译后的Java代码，这个编译后的代码就是Java字节码，存储在.class类文件中。 跨平台的基石 Java字节码具有“平台无关性”和“语言无关性”。 平台无关性： 字节码可以在任何支持JVM的平台上运行，实现“一次编写，到处运行” 语言无...","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-07-19T00:00:00.000Z","category":"JVM","tag":"JVM","order":2,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/jvm/specs/class.html"}],["meta",{"property":"og:title","content":"类文件结构"}],["meta",{"property":"og:description","content":"类文件结构 计算机只能运行由0和1构成的二进制格式。 要运行Java程序，必须先通过Java虚拟机（JVM）执行编译后的Java代码，这个编译后的代码就是Java字节码，存储在.class类文件中。 跨平台的基石 Java字节码具有“平台无关性”和“语言无关性”。 平台无关性： 字节码可以在任何支持JVM的平台上运行，实现“一次编写，到处运行” 语言无..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/202407200209120.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-26T18:44:14.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-07-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-26T18:44:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类文件结构\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/202407200209120.png\\",\\"https://img.geekyspace.cn/pictures/2024/202407220149546.png\\",\\"https://img.geekyspace.cn/pictures/2024/202407230642248.png\\",\\"https://img.geekyspace.cn/pictures/2024/202407251001215.png\\"],\\"datePublished\\":\\"2024-07-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-26T18:44:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[{"level":2,"title":"跨平台的基石","slug":"跨平台的基石","link":"#跨平台的基石","children":[]},{"level":2,"title":"Class类文件结构（理论）","slug":"class类文件结构-理论","link":"#class类文件结构-理论","children":[{"level":3,"title":"魔数","slug":"魔数","link":"#魔数","children":[]},{"level":3,"title":"Class文件版本号","slug":"class文件版本号","link":"#class文件版本号","children":[]},{"level":3,"title":"常量池","slug":"常量池","link":"#常量池","children":[]},{"level":3,"title":"访问标志","slug":"访问标志","link":"#访问标志","children":[]},{"level":3,"title":"类索引、父类索引与接口索引集合","slug":"类索引、父类索引与接口索引集合","link":"#类索引、父类索引与接口索引集合","children":[]},{"level":3,"title":"字段表集合","slug":"字段表集合","link":"#字段表集合","children":[]},{"level":3,"title":"方法表集合","slug":"方法表集合","link":"#方法表集合","children":[]},{"level":3,"title":"属性表集合","slug":"属性表集合","link":"#属性表集合","children":[]}]},{"level":2,"title":"编译字节码分析（实践）","slug":"编译字节码分析-实践","link":"#编译字节码分析-实践","children":[]}],"git":{"createdTime":1722019454000,"updatedTime":1722019454000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":18.6,"words":5579},"filePathRelative":"md/jvm/specs/class.md","localizedDate":"2024年7月19日","excerpt":"\\n<blockquote>\\n<p>计算机只能运行由0和1构成的二进制格式。\\n要运行Java程序，必须先通过Java虚拟机（JVM）执行编译后的Java代码，这个编译后的代码就是<strong>Java字节码</strong>，存储在<code>.class</code>类文件中。</p>\\n</blockquote>\\n<h2>跨平台的基石</h2>\\n<p>Java字节码具有“平台无关性”和“语言无关性”。</p>\\n<ul>\\n<li><strong>平台无关性：</strong> 字节码可以在任何支持JVM的平台上运行，实现“一次编写，到处运行”</li>\\n<li><strong>语言无关性：</strong> 多种编程语言可以编译成字节码并在JVM（GraalVM）上运行，不仅限于Java</li>\\n</ul>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{O as comp,B as data};
