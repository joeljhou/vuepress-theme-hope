import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as n,c as r,a as e,b as l,d as c,e as a}from"./app-BwhhRzDx.js";const s={},p=a('<h1 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h1><blockquote><p><strong>运行时数据区</strong>是指Java虚拟机（JVM）在运行Java程序时用于存储数据的内存区域，分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。</p></blockquote><figure><img src="https://img.geekyspace.cn/pictures/2024/202408102247073.png" alt="Java虚拟机运行时数据区" tabindex="0" loading="lazy"><figcaption>Java虚拟机运行时数据区</figcaption></figure><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><blockquote><p><strong>程序计数器</strong>（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行字节码的行号指示器。 每个线程都有一个独立的程序计数器，用于记录线程执行的位置，以便线程切换后能恢复到正确的位置。</p></blockquote><ul><li>Java方法执行时，程序计数器记录字节码指令地址</li><li>Native方法执行时，程序计数器为空（Undefined）</li><li>此区域不抛出<code>OutOfMemoryError</code>异常</li></ul><h2 id="java虚拟机栈" tabindex="-1"><a class="header-anchor" href="#java虚拟机栈"><span>Java虚拟机栈</span></a></h2><blockquote><p><strong>Java虚拟机栈</strong>（Java Virtual Machine Stack）是线程私有的内存区域，其生命周期与线程相同。 它描述了方法执行的内存模型。当方法被执行时，JVM 会为该方法同步创建一个<strong>栈帧</strong>（Stack Frame）。</p></blockquote><ul><li>每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</li><li>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li><li>栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。</li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/202408112312001.png" alt="栈帧的概念结构" tabindex="0" loading="lazy"><figcaption>栈帧的概念结构</figcaption></figure><ul><li><strong>局部变量表（Local Variable Table）：</strong> 方法执行时用于存储方法参数和局部变量的一块内存空间。</li><li><strong>操作数栈（Operand Stack）：</strong> 后进先出（LIFO）结构，用于方法执行时存储执行指令产生中间结果。</li><li><strong>动态链接（Dynamic Linking）：</strong> 指在方法调用时，将符号引用转换为直接引用的过程。</li><li><strong>方法返回地址(Return Address)：</strong> 指方法调用后返回位置的地址。</li></ul><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h2><blockquote><p>本地方法栈（Native Method Stack）与虚拟机栈功能非常相似，其区别在于：</p><ul><li>虚拟机栈为虚拟机执行Java方法（字节码）服务</li><li>本地方法栈则为虚拟机执行本地（Native）方法服务</li></ul></blockquote><p>HotSpot虚拟机把虚拟机栈和本地方法栈合二为一</p><h2 id="java堆" tabindex="-1"><a class="header-anchor" href="#java堆"><span>Java堆</span></a></h2><blockquote><p>Java堆（Java Heap）是虚拟机管理的内存中最大的一块，线程共享，并在虚拟机启动时创建。 它的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在堆上分配。</p></blockquote><figure><img src="https://img.geekyspace.cn/pictures/2024/202407172004168.png" alt="堆内存模型" tabindex="0" loading="lazy"><figcaption>堆内存模型</figcaption></figure><ul><li><strong>新生代 (Young Generation)：</strong><ul><li>通常由Eden区和两个Survivor区(被称为from/to或s0/s1)组成，默认比例是<code>8:1:1</code>。</li><li>大多数新创建的对象都在新生代分配内存，被填满时会触发一次<code>Minor GC</code>（小型垃圾回收）。</li><li>使用的垃圾收集算法通常是复制算法，将存活的对象复制到Survivor区，然后清理Eden区和使用过的Survivor区。</li></ul></li><li><strong>老年代 (Old Generation / Tenured Generation)：</strong><ul><li>通过多次新生代垃圾收集后任然存活的对象会被晋升到老年代。</li><li>老年代的对象相对来说生命周期较长，垃圾回收（<code>Major GC</code>或<code>Full GC</code>）相对较少，一旦发生，会比<code>Minor GC</code>耗时。</li><li>使用的垃圾收集算法通常是标记-清除算法或标记-整理算法。</li></ul></li><li><strong>元空间 (Metaspace)：</strong><ul><li>从JDK8开始，永久代（PermGen）被元空间取代。</li><li>元空间使用的是本地内存，而不是JVM堆内存。</li><li>元空间的大小仅受本地内存限制，但可以通过参数进行调整。</li></ul></li></ul>',18),g={href:"https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java",target:"_blank",rel:"noopener noreferrer"},d=a('<h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h2><blockquote><p>方法区（Method Area）是JVM规范中定义的一个概念，用于被虚拟机加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据。</p></blockquote><p>在Java8之前，方法区被称为“<strong>永久代</strong>（PermGen）”。</p><p>从Java8开始，方法区的实现被改为<strong>元空间</strong>（Metaspace），元空间使用的是本地内存，而不是像永久代那样在JVM的堆内存中分配。</p><h2 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池"><span>运行时常量池</span></a></h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><h2 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存"><span>直接内存</span></a></h2>',8);function u(m,h){const t=o("ExternalLinkIcon");return n(),r("div",null,[p,e("p",null,[e("a",g,[l("DigitalOcean——Java （JVM） 内存模型 - Java 中的内存管理"),c(t)])]),d])}const f=i(s,[["render",u],["__file","runtime-data-areas.html.vue"]]),k=JSON.parse('{"path":"/md/jvm/part2/runtime-data-areas.html","title":"运行时数据区","lang":"zh-CN","frontmatter":{"title":"运行时数据区","description":"运行时数据区 运行时数据区是指Java虚拟机（JVM）在运行Java程序时用于存储数据的内存区域，分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。 Java虚拟机运行时数据区Java虚拟机运行时数据区 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行字节码的...","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-08-10T00:00:00.000Z","category":"JVM","tag":"JVM","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/jvm/part2/runtime-data-areas.html"}],["meta",{"property":"og:title","content":"运行时数据区"}],["meta",{"property":"og:description","content":"运行时数据区 运行时数据区是指Java虚拟机（JVM）在运行Java程序时用于存储数据的内存区域，分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。 Java虚拟机运行时数据区Java虚拟机运行时数据区 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前线程所执行字节码的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/202408102247073.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T19:06:54.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-08-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T19:06:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运行时数据区\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/202408102247073.png\\",\\"https://img.geekyspace.cn/pictures/2024/202408112312001.png\\",\\"https://img.geekyspace.cn/pictures/2024/202407172004168.png\\"],\\"datePublished\\":\\"2024-08-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T19:06:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"Java虚拟机栈","slug":"java虚拟机栈","link":"#java虚拟机栈","children":[]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"Java堆","slug":"java堆","link":"#java堆","children":[]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":2,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]},{"level":2,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]}],"git":{"createdTime":1723403214000,"updatedTime":1723403214000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":3.98,"words":1193},"filePathRelative":"md/jvm/part2/runtime-data-areas.md","localizedDate":"2024年8月10日","excerpt":"\\n<blockquote>\\n<p><strong>运行时数据区</strong>是指Java虚拟机（JVM）在运行Java程序时用于存储数据的内存区域，分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。</p>\\n</blockquote>\\n<figure><img src=\\"https://img.geekyspace.cn/pictures/2024/202408102247073.png\\" alt=\\"Java虚拟机运行时数据区\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Java虚拟机运行时数据区</figcaption></figure>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{f as comp,k as data};
