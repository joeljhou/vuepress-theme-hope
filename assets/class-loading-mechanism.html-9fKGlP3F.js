import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as a}from"./app-DDETv5N-.js";const o={},i=a('<h1 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制"><span>类加载机制</span></a></h1><h2 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h2><p>类的生命周期分为以下7个阶段，其中解析可以在初始化之后，以支持Java的运行时绑定特性。</p><figure><img src="https://img.geekyspace.cn/pictures/2024/202407260441081.png" alt="类的生命周期" tabindex="0" loading="lazy"><figcaption>类的生命周期</figcaption></figure><p>注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。</p><p><strong>1、初始化时机的六种情况称为“主动引用”</strong></p><p>在Java虚拟机规范中，“有且只有”以下六种情况会触发类的初始化，称为对一个类的<strong>主动引用</strong>：</p><ol><li>创建对象实例时、获取或设置静态字段值时（非常量）、调用类的静态方法时。即遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或<code>invokestatic</code>字节码指令这 4 种指令。</li><li>通过反射机制（如<code>Class.forName()</code>）调用类时。</li><li>初始化某个子类时，若其父类还没有初始化，则先初始化父类。</li><li>当虚拟机启动时，指定的包含<code>main()</code>方法的主类会被初始化。</li><li>使用JDK 1.7引入动态语言支持时，若<code>java.lang.invoke.MethodHandle</code> 实例解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>或<code>REF_newInvokeSpecial</code>，若其对应类没有初始化，则先初始化。</li><li>当接口中定义了JDK 1.8新增的默认方法时，若实现类初始化，则需要先初始化该接口。</li></ol><p><strong>2、“被动引用”的例子</strong></p><p>除了以上六种场景外，所有其他引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p><ul><li><strong>例1：通过子类引用父类的静态字段，不会导致子类初始化，只有父类会被初始化</strong><ul><li>子类是否加载和验证，取决于虚拟机的具体实现。</li><li>在HotSpot虚拟机（JDK 1.8 亲测）中，使用<code>-XX:+TraceClassLoading</code>观察到此操作会导致子类加载。</li></ul></li><li><strong>例2：通过数组定义来引用类，不会触发此类的初始化</strong><ul><li>例如，<code>MyClass[] sca = new MyClass[10];</code>，不会初始化<code>MyClass</code>类</li><li>但这段代码触发了另一个名为<code>[L包名.MyClass</code>的类的初始化阶段。它是由虚拟机自动生成的、继承自<code>java.lang.Object</code> 的子类，由字节码指令<code>newarray</code>触发。这个类表示<code>MyClass</code>的一维数组，包含数组应有的属性和方法（如<code>public</code>的<code>length</code> 属性和<code>clone()</code>方法）。</li><li>Java语言对数组的访问比C/C++更安全，因为这个类包装了数组元素的访问，C/C++中直接翻译为对数组指针的移动。 在Java语言里，发生数组越界时会抛出<code>java.lang.ArrayIndexOutOfBoundsException</code>异常，避免非法内存访问。</li></ul></li><li><strong>例3：引用常量不会触发定义常量的类的初始化</strong><ul><li>因为常量在编译阶段就会被存入调用类的常量池中。</li></ul></li></ul><p><strong>3、接口的“加载与初始化”与类的差异</strong></p><p>接口的加载与初始化过程与类略有不同，差异如下：</p><ul><li><strong>静态变量的初始化：</strong> 虽然接口不能使用静态语句块<code>static{}</code>来输出初始化信息，编译器仍会为接口生成<code>&lt;clinit&gt;()</code> 类构造器，用于初始化接口中定义的静态变量。</li><li><strong>初始化触发条件：</strong> 类的初始化需要其所有父类已经初始化，而接口的初始化则不要求其父接口全部初始化。接口只有在实际使用父接口中的成员（如引用接口中定义的常量）时，才会进行初始化。</li></ul><h2 id="类加载的过程" tabindex="-1"><a class="header-anchor" href="#类加载的过程"><span>类加载的过程</span></a></h2><p>Java类加载过程主要分为加载、连接（验证、准备、解析）、初始化三个阶段。</p><h3 id="加载" tabindex="-1"><a class="header-anchor" href="#加载"><span>加载</span></a></h3><blockquote><ol><li>通过类的全限定名获取定义此类的二进制字节流。</li><li>并将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li></ol></blockquote><ul><li><strong>类文件来源：</strong><ul><li>通常包括本地文件系统、压缩文件（如JAR、WAR）、网络、数据库、加密文件（防止反编译）、运行时动态生成，以及由其他文件生成（如JSP应用生成的Class文件）。</li></ul></li><li><strong>数组类加载：</strong><ul><li>数组类本身不通过类加载器创建，而是由Java虚拟机直接在内存中构建出来。但数组类的元素类型最终还是靠类加载器来完成加载。</li></ul></li></ul><h3 id="验证" tabindex="-1"><a class="header-anchor" href="#验证"><span>验证</span></a></h3><blockquote><p>验证是连接阶段的第一步，目的是确保字节码的正确性和安全性，包括文件格式验证、元数据验证、字节码验证和符号引用验证四个阶段。</p></blockquote><p>验证阶段大致上会完成下面四个阶段的检验动作：</p><ol><li><strong>文件格式验证：</strong> 检查字节流是否符合Class文件的格式规范。</li><li><strong>元数据验证：</strong> 对类的元数据信息进行语义校验，确保其符合Java语言的语法和语意规则。</li><li><strong>字节码验证：</strong> 通过数据流分析和控制流分析，确保字节码指令的合法性和逻辑正确性。</li><li><strong>符号引用验证：</strong> 在解析阶段之前，检查符号引用是否能被正确解析。</li></ol><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备"><span>准备</span></a></h3><blockquote><p>准备阶段为类中的静态变量分配内存并设置初始值。静态变量的内存分配发生在方法区中。</p></blockquote><ul><li>在 JDK 7及之前，HotSpot使用<strong>永久代</strong>（PerGen）来实现方法区，存放在堆内存中</li><li>在 JDK 8及之后，永久代被移除，取而代之的是<strong>元空间</strong>（Metaspace），存放在操作系统本地内存中</li></ul><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><blockquote><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><ul><li><strong>符号引用（Symbolic References）：</strong> 字符串形式表示的对目标的逻辑引用</li><li><strong>直接引用（Direct References）：</strong> 是直接定位到目标内存位置的指针、偏移量或句柄。</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h3><blockquote><p>类加载过程的最后一个阶段，负责执行类构造器方法 <code>&lt;clinit&gt;</code>。</p></blockquote><ul><li><strong>自动生成：</strong> 由javac编译自动生成<code>&lt;clinit&gt;</code>，是所有静态变量赋值和静态代码块的集合。</li><li><strong>非法前向引用：</strong> 静态语句块中只能访问定义在其之前的变量。</li><li>父类的 <code>&lt;clinit&gt;</code> 方法会先于子类的 <code>&lt;clinit&gt;</code> 方法执行。</li><li>如果一个类没有静态语句块和静态变量的赋值操作，那么编译器可能不会生成 <code>&lt;clinit&gt;</code> 方法。</li><li>多线程环境下，类的初始化可能会出现并发问题，JVM会保证<code>&lt;clinit&gt;</code>方法的线程安全执行。</li></ul><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h2><blockquote><p>加载阶段“通过一个类的全限定名来获取描述该类的二进制字节流”，这个动作的代码被称为“类加载器”（Class Loader）。</p></blockquote><h3 id="类与类加载器" tabindex="-1"><a class="header-anchor" href="#类与类加载器"><span>类与类加载器</span></a></h3><h3 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型"><span>双亲委派模型</span></a></h3><h3 id="破坏双亲委派模型" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派模型"><span>破坏双亲委派模型</span></a></h3>',38),n=[i];function c(s,r){return t(),l("div",null,n)}const g=e(o,[["render",c],["__file","class-loading-mechanism.html.vue"]]),h=JSON.parse('{"path":"/md/jvm/part3/class-loading-mechanism.html","title":"类加载机制","lang":"zh-CN","frontmatter":{"title":"类加载机制","description":"类加载机制 类的生命周期 类的生命周期分为以下7个阶段，其中解析可以在初始化之后，以支持Java的运行时绑定特性。 类的生命周期类的生命周期 注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。 1、初始化时机的六种情况称为“主动引用” 在Java虚拟机规范中，“有且只有”以下六种情况会触发类的初始化，称为对一个类的主...","author":"会敲代码的程序猿","isOriginal":true,"date":"2024-07-20T00:00:00.000Z","category":"JVM","tag":"JVM","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/jvm/part3/class-loading-mechanism.html"}],["meta",{"property":"og:title","content":"类加载机制"}],["meta",{"property":"og:description","content":"类加载机制 类的生命周期 类的生命周期分为以下7个阶段，其中解析可以在初始化之后，以支持Java的运行时绑定特性。 类的生命周期类的生命周期 注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。 1、初始化时机的六种情况称为“主动引用” 在Java虚拟机规范中，“有且只有”以下六种情况会触发类的初始化，称为对一个类的主..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/202407260441081.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-08T13:25:24.000Z"}],["meta",{"property":"article:author","content":"会敲代码的程序猿"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-07-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-08T13:25:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类加载机制\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/202407260441081.png\\"],\\"datePublished\\":\\"2024-07-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-08T13:25:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"会敲代码的程序猿\\"}]}"]]},"headers":[{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[]},{"level":2,"title":"类加载的过程","slug":"类加载的过程","link":"#类加载的过程","children":[{"level":3,"title":"加载","slug":"加载","link":"#加载","children":[]},{"level":3,"title":"验证","slug":"验证","link":"#验证","children":[]},{"level":3,"title":"准备","slug":"准备","link":"#准备","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":3,"title":"初始化","slug":"初始化","link":"#初始化","children":[]}]},{"level":2,"title":"类加载器","slug":"类加载器","link":"#类加载器","children":[{"level":3,"title":"类与类加载器","slug":"类与类加载器","link":"#类与类加载器","children":[]},{"level":3,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[]},{"level":3,"title":"破坏双亲委派模型","slug":"破坏双亲委派模型","link":"#破坏双亲委派模型","children":[]}]}],"git":{"createdTime":1723123524000,"updatedTime":1723123524000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":6.01,"words":1803},"filePathRelative":"md/jvm/part3/class-loading-mechanism.md","localizedDate":"2024年7月20日","excerpt":"\\n<h2>类的生命周期</h2>\\n<p>类的生命周期分为以下7个阶段，其中解析可以在初始化之后，以支持Java的运行时绑定特性。</p>\\n<figure><img src=\\"https://img.geekyspace.cn/pictures/2024/202407260441081.png\\" alt=\\"类的生命周期\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>类的生命周期</figcaption></figure>\\n<p>注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。</p>\\n<p><strong>1、初始化时机的六种情况称为“主动引用”</strong></p>","copyright":{"author":"会敲代码的程序猿"},"autoDesc":true}');export{g as comp,h as data};
